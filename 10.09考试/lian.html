<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div></div>
    <script>
        // class Calculator {
        //     constructor(initialMemory = 0) {
        //         this.memory = initialMemory;
        //     }
        //     // 增加计算器内存
        //     addToMemory(value) {
        //         this.memory = this.memory * 1 + value * 1;
        //     }
        //     // 从计算器内存中减去值
        //     subtractFromMemory(value) {
        //         this.memory = this.memory * 1 - value * 1;
        //     }
        //     // 将计算器内存的值设为0
        //     clearMemory() {
        //         this.memory = 0;
        //     }
        //     // 将内存中的值乘以倍数
        //     multiplyBy(multiplier) {
        //         this.memory *= multiplier;
        //     }
        //     // 将内存中的值除以倍数
        //     exceptBy(multiplier) {
        //         this.memory /= multiplier;
        //     }
        //     // 获取计算器内存中的值
        //     getMemory() {
        //         return this.memory;
        //     }
        // }
        // let user1 = prompt("请输入第一位值：");
        // let users = prompt("请输入符号：");
        // let user2 = prompt("请输入第二位值：");
        // const calculator = new Calculator(user1); // 初始化计算器
        // switch (users) {
        //     case "+":
        //         calculator.addToMemory(user2); // 增加
        //         console.log("加法得" + calculator.getMemory());
        //         break;
        //     case "-":
        //         calculator.subtractFromMemory(user2); // 减去
        //         console.log("减法得" + calculator.getMemory());
        //         break;
        //     case "*":
        //         calculator.multiplyBy(user2); // 乘以
        //         console.log("乘法得" + calculator.getMemory());
        //         break;
        //     case "/":
        //         calculator.exceptBy(user2); // 除以
        //         console.log("除法得" + calculator.getMemory());
        //         break;
        //     default:
        //         console.log("无效运算符");
        //         break;
        // }
        // calculator.clearMemory(); // 清空


        // function deepCuarl(obj1, obj2) {
        //     // 检查两个对象是否是同一个对象
        //     if (obj1 === obj2) {
        //         return true;
        //     };
        //     // 检查两个对象是否具有相同的结构
        //     if (typeof obj1 !== 'object' || obj1 === null || typeof obj2 !== 'object' || obj2 === null) {
        //         return false;
        //     };
        //     // 检查两个对象是否有相同长度的属性
        //     const keys1 = Object.keys(obj1);
        //     const keys2 = Object.keys(obj2);
        //     if (keys1.length !== keys2.length) {
        //         return false;
        //     }
        //     // 遍历并比较两个对象的所有属性
        //     for (let key of keys1) {
        //         if (!deepCuarl(obj1[key], obj2[key])) {
        //             return false;
        //         }
        //     }
        //     return true;
        // }
        // let arr1 = { a: 1, b: 2, c: 3 };
        // let arr2 = { a: 1, b: 2, c: 3 };
        // let arr3 = { a: 1, b: 2, c: { a: 3, b: 2 } };
        // console.log(deepCuarl(arr1, arr2)); // 输出 true
        // console.log(deepCuarl(arr1, arr3)); // 输出 false


        // Array.prototype.mydelete = function () {
        //     var indices = Array.from(arguments);
        //     indices.sort((a, b) => b - a); // 对索引进行排序，以确保从后往前删除

        //     for (let i = 0; i < this.length; i++) {
        //         if (indices.includes(i)) {
        //             this.splice(i, 1);
        //             i--; // 由于删除操作会使数组长度减小，因此需要手动减小i值以避免跳过下一个元素
        //         }
        //     }

        //     return this;
        // }

        // let arr = ['a', 'b', 'c', 'd', 'e'];
        // arr.mydelete(1, 3); // 输出: ['a', 'c']
        // console.log(arr);
        // console.log(arr);
        // function myDelete(arr, deleteFunc) {
        //     for (let i = 0; i < arr.length; i++) {
        //         if (deleteFunc(arr[i])) {
        //             arr.splice(i, 1);
        //             // 如果删除操作使得数组长度改变，我们需要手动减小索引以避免跳过下一个元素
        //             i--;
        //         }
        //     }
        //     return arr;
        // }


        // 定义一个删除函数，这个函数接受一个数组元素，返回一个布尔值表示是否应该删除该元素
        // deleteFunc = function (index, arr) {

        //     if (index !== 0 && index !== 1) { // 要删除的是第一和第二个元素，其他元素保留
        //         arr[index] = arr[index + 1]; // 将下一个元素移到当前位置，覆盖要删除的元素
        //     }
        // }
        // for (let i = 0; i < arr.length; i++) {
        //     deleteFunc(i, arr);
        // }
        // let arr = ['a', 'b', 'c', 'd', 'e', 'a', 'b'];
        // console.log(myDelete(arr, deleteFunc)); // 输出: ['c', 'd', 'e']


        // let brr = ['a', 'b', 'c', 'd', 'e'];
        // console.log("原数据arr = ['a', 'b', 'c', 'd', 'e']");
        // // for (let i = 0; i <= arr.length - 1; i++) {

        // //     deleteFunc(i, arr);//0，['a', 'b', 'c', 'd', 'e'];...

        // // }
        // // function deleteFunc(i, arr) {
        // //     if (i == 1 && i == 2) { // 判断删除的元素，其他元素保留
        // //         arr.splice(i, 1);  // 删除
        // //         console.log(i);
        // //     }
        // // };
        // Array.prototype.mydelete = function () {
        //     let brr1 = Array.from(arguments)
        //     brr1.sort((a, b) => b - a);
        //     for (let b of brr1) {
        //         if (b >= 0 && b < this.length) {
        //             this.splice(b, 1)
        //         }
        //     }
        // }
        // brr.mydelete(1, 2)
        // console.log(brr);


        // .4 假设有一个名为fetchData() 的异步函数用于获取数据，
        //    它返回一个 Promise 对象，成功时返回数据，失败时返回错误信息。
        //    请根据以下要求完成题目:1.定义 fetchData()函数，获取数据并打印，
        //    2.对于同时需要获取两个数据的情况，使用 Promise.all()实现并行请求，
        //    并在两个数据都返回后打印
        //    3.使用 Promise.race() 实现一个超时函数，该函数接受两个参数:
        //    一个是超时时间另一个是Promise 对象。如果 Promise 对象在指定时间
        //    内没有返回结果，则视作失败，并返回一个超时错误。
        // 1. 定义 fetchData() 函数，获取数据并打印  
        function fetchData(url) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    if (url !== null) {
                        resolve(`数据1: ${url}`);
                    } else {
                        reject(`错误1: ${url}`);
                    }
                }, 1000);
            });
        }

        fetchData('url1')
            .then(data => {
                console.log(data);
            })
            .catch(error => {
                console.error('错误:', error);
            });

        // 2. 对于同时需要获取两个数据的情况，使用 Promise.all() 实现并行请求，并在两个数据都返回后打印  
        let promise1 = fetchData('url1');
        let promise2 = fetchData('url2');

        Promise.all([promise1, promise2])
            .then(([data1, data2]) => {
                console.log(data1, data2);
            })
            .catch((error) => {
                console.error('错误:', error);
            });

        // 3. 使用 Promise.race() 实现一个超时函数，该函数接受两个参数:一个是超时时间另一个是 Promise 对象。如果 Promise 对象在指定时间内没有返回结果，则视作失败，并返回一个超时错误。  
        function fetchDataWithTimeout(url, timeout) {
            return new Promise((resolve, reject) => {
                let promise = fetchData(url);
                let id = setTimeout(() => {
                    clearTimeout(id);
                    reject(`超时错误: Promise 没有在 ${timeout}ms 内完成.`);
                }, timeout);
            });
        }

        fetchDataWithTimeout('url1', 2000)
            .then(data => console.log(data))
            .catch(error => console.error(error));
    </script>
</body>

</html>